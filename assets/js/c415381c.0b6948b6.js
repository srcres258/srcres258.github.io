"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[563],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=o.createContext({}),s=function(e){var t=o.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=s(e.components);return o.createElement(d.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,d=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=s(n),u=r,f=c["".concat(d,".").concat(u)]||c[u]||p[u]||a;return n?o.createElement(f,i(i({ref:t},m),{},{components:n})):o.createElement(f,i({ref:t},m))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=u;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var s=2;s<a;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},6794:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var o=n(7462),r=(n(7294),n(3905));const a={},i="Custom Model Loaders",l={unversionedId:"rendering/modelloaders/index",id:"rendering/modelloaders/index",title:"Custom Model Loaders",description:"A \"model\" is simply a shape. It can be a simple cube, it can be several cubes, it can be a truncated icosidodecahedron, or anything in between. Most models you'll see will be in the vanilla JSON format. Models in other formats are loaded into IUnbakedGeometrys by an IGeometryLoader at runtime. Forge provides default implementations for WaveFront OBJ files, buckets, composite models, models in different render layers, and a reimplementation of Vanilla's builtin/generated item model. Most things do not care about what loaded the model or what format it's in as they are all eventually represented by an BakedModel in code.",source:"@site/docs/rendering/modelloaders/index.md",sourceDirName:"rendering/modelloaders",slug:"/rendering/modelloaders/",permalink:"/docs/rendering/modelloaders/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Part Visibility",permalink:"/docs/rendering/modelextensions/visibility"},next:{title:"BakedModel",permalink:"/docs/rendering/modelloaders/bakedmodel"}},d={},s=[{value:"WaveFront OBJ Models",id:"wavefront-obj-models",level:2}],m={toc:s},c="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"custom-model-loaders"},"Custom Model Loaders"),(0,r.kt)("p",null,'A "model" is simply a shape. It can be a simple cube, it can be several cubes, it can be a truncated icosidodecahedron, or anything in between. Most models you\'ll see will be in the vanilla JSON format. Models in other formats are loaded into ',(0,r.kt)("inlineCode",{parentName:"p"},"IUnbakedGeometry"),"s by an ",(0,r.kt)("inlineCode",{parentName:"p"},"IGeometryLoader")," at runtime. Forge provides default implementations for WaveFront OBJ files, buckets, composite models, models in different render layers, and a reimplementation of Vanilla's ",(0,r.kt)("inlineCode",{parentName:"p"},"builtin/generated")," item model. Most things do not care about what loaded the model or what format it's in as they are all eventually represented by an ",(0,r.kt)("inlineCode",{parentName:"p"},"BakedModel")," in code."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Specifying a custom model loader through the top-level ",(0,r.kt)("inlineCode",{parentName:"p"},"loader")," entry in a model JSON will cause the ",(0,r.kt)("inlineCode",{parentName:"p"},"elements")," entry to be ignored unless it is consumed by the custom loader. All other vanilla entries will still be loaded and available in the unbaked ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockModel")," representation and may be consumed outside of the custom loader.")),(0,r.kt)("h2",{id:"wavefront-obj-models"},"WaveFront OBJ Models"),(0,r.kt)("p",null,"Forge adds a loader for the ",(0,r.kt)("inlineCode",{parentName:"p"},".obj")," file format. To use these models, the JSON must reference the ",(0,r.kt)("inlineCode",{parentName:"p"},"forge:obj")," loader. This loader accepts any model location that is in a registered namespace and whose path ends in ",(0,r.kt)("inlineCode",{parentName:"p"},".obj"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},".mtl")," file should be placed in the same location with the same name as the ",(0,r.kt)("inlineCode",{parentName:"p"},".obj")," to be used automatically. The ",(0,r.kt)("inlineCode",{parentName:"p"},".mtl")," file will probably have to be manually edited to change the paths pointing to textures defined within the JSON. Additionally, the V axis for textures may be flipped depending on the external program that created the model (i.e. V = 0 may be the bottom edge, not the top). This may be rectified in the modelling program itself or done in the model JSON like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{\n  // Add the following line on the same level as a \'model\' declaration\n  "loader": "forge:obj",\n  "flip_v": true,\n  "model": "examplemod:models/block/model.obj",\n  "textures": {\n    // Can refer to in .mtl using #texture0\n    "texture0": "minecraft:block/dirt",\n    "particle": "minecraft:block/dirt"\n  }\n}\n')))}p.isMDXComponent=!0}}]);