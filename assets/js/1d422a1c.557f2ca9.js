"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[2951],{3905:(e,t,o)=>{o.d(t,{Zo:()=>p,kt:()=>m});var n=o(7294);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){r(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},b=n.forwardRef((function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=d(o),b=r,m=c["".concat(s,".").concat(b)]||c[b]||u[b]||a;return o?n.createElement(m,i(i({ref:t},p),{},{components:o})):n.createElement(m,i({ref:t},p))}));function m(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=b;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:r,i[1]=l;for(var d=2;d<a;d++)i[d]=o[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}b.displayName="MDXCreateElement"},1673:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var n=o(7462),r=(o(7294),o(3905));const a={},i="Loot Table Generation",l={unversionedId:"datagen/server/loottables",id:"datagen/server/loottables",title:"Loot Table Generation",description:"Loot tables can be generated for a mod by constructing a new LootTableProvider and providing LootTableProvider$SubProviderEntrys. The provider must be added to the DataGenerator.",source:"@site/docs/datagen/server/loottables.md",sourceDirName:"datagen/server",slug:"/datagen/server/loottables",permalink:"/docs/datagen/server/loottables",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Global Loot Modifier Generation",permalink:"/docs/datagen/server/glm"},next:{title:"Recipe Generation",permalink:"/docs/datagen/server/recipes"}},s={},d=[{value:"<code>LootTableSubProvider</code>",id:"loottablesubprovider",level:2},{value:"<code>BlockLootSubProvider</code> and <code>EntityLootSubProvider</code> Subclasses",id:"blocklootsubprovider-and-entitylootsubprovider-subclasses",level:3},{value:"Loot Table Builders",id:"loot-table-builders",level:2},{value:"LootTable",id:"loottable",level:3},{value:"LootPool",id:"lootpool",level:3},{value:"LootPoolEntryContainer",id:"lootpoolentrycontainer",level:3},{value:"LootItemCondition",id:"lootitemcondition",level:3},{value:"LootItemFunction",id:"lootitemfunction",level:3},{value:"NbtProvider",id:"nbtprovider",level:4},{value:"NumberProvider",id:"numberprovider",level:3},{value:"ScoreboardNameProvider",id:"scoreboardnameprovider",level:4}],p={toc:d},c="wrapper";function u(e){let{components:t,...o}=e;return(0,r.kt)(c,(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"loot-table-generation"},"Loot Table Generation"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/docs/resources/server/loottables"},"Loot tables")," can be generated for a mod by constructing a new ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTableProvider")," and providing ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTableProvider$SubProviderEntry"),"s. The provider must be ",(0,r.kt)("a",{parentName:"p",href:"/docs/datagen/#data-providers"},"added")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"DataGenerator"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// On the MOD event bus\n@SubscribeEvent\npublic void gatherData(GatherDataEvent event) {\n    event.getGenerator().addProvider(\n        // Tell generator to run only when server data are generating\n        event.includeServer(),\n        output -> new MyLootTableProvider(\n          output,\n          // Specify registry names of tables that are required to generate, or can leave empty\n          Collections.emptySet(),\n          // Sub providers which generate the loot\n          List.of(subProvider1, subProvider2, /*...*/)\n        )\n    );\n}\n")),(0,r.kt)("h2",{id:"loottablesubprovider"},(0,r.kt)("inlineCode",{parentName:"h2"},"LootTableSubProvider")),(0,r.kt)("p",null,"Each ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTableProvider$SubProviderEntry")," takes in a supplied ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTableSubProvider"),", which generates the loot table, for a given ",(0,r.kt)("inlineCode",{parentName:"p"},"LootContextParamSet"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTableSubProvider")," contains a method which takes in the writer (",(0,r.kt)("inlineCode",{parentName:"p"},"BiConsumer<ResourceLocation, LootTable.Builder>"),") to generate a table."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class ExampleSubProvider implements LootTableSubProvider {\n\n  // Used to create a factory method for the wrapping Supplier\n  public ExampleSubProvider() {}\n\n  // The method used to generate the loot tables\n  @Override\n  public void generate(BiConsumer<ResourceLocation, LootTable.Builder> writer) {\n    // Generate loot tables here by calling writer#accept\n  }\n}\n")),(0,r.kt)("p",null,"The table can then be added to ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTableProvider#getTables")," for any available ",(0,r.kt)("inlineCode",{parentName:"p"},"LootContextParamSet"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// In the list passed into the LootTableProvider constructor\nnew LootTableProvider.SubProviderEntry(\n  ExampleSubProvider::new,\n  // Loot table generator for the 'empty' param set\n  LootContextParamSets.EMPTY\n)\n")),(0,r.kt)("h3",{id:"blocklootsubprovider-and-entitylootsubprovider-subclasses"},(0,r.kt)("inlineCode",{parentName:"h3"},"BlockLootSubProvider")," and ",(0,r.kt)("inlineCode",{parentName:"h3"},"EntityLootSubProvider")," Subclasses"),(0,r.kt)("p",null,"For ",(0,r.kt)("inlineCode",{parentName:"p"},"LootContextParamSets#BLOCK")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"#ENTITY"),", there are special types (",(0,r.kt)("inlineCode",{parentName:"p"},"BlockLootSubProvider")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"EntityLootSubProvider")," respectively) which provide additional helper methods for creating and validating that there are loot tables."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockLootSubProvider"),"'s constructor takes in a list of items, which are explosion resistant to determine whether the loot table can be generated if a block is exploded, and a ",(0,r.kt)("inlineCode",{parentName:"p"},"FeatureFlagSet"),", which determines whether the block is enabled so that a loot table is generated for it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// In some BlockLootSubProvider subclass\npublic MyBlockLootSubProvider() {\n  super(Collections.emptySet(), FeatureFlags.REGISTRY.allFlags());\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"EntityLootSubProvider"),"'s constructor takes in a ",(0,r.kt)("inlineCode",{parentName:"p"},"FeatureFlagSet"),", which determines whether the entity type is enabled so that a loot table is generated for it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// In some EntityLootSubProvider subclass\npublic MyEntityLootSubProvider() {\n  super(FeatureFlags.REGISTRY.allFlags());\n}\n")),(0,r.kt)("p",null,"To use them, all registered objects must be supplied to either ",(0,r.kt)("inlineCode",{parentName:"p"},"BlockLootSubProvider#getKnownBlocks")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"EntityLootSubProvider#getKnownEntityTypes")," respectively. These methods are to make sure all objects within the iterable has a loot table."),(0,r.kt)("p",null,"!!! tip\nIf ",(0,r.kt)("inlineCode",{parentName:"p"},"DeferredRegister")," is being used to register a mod's objects, then the ",(0,r.kt)("inlineCode",{parentName:"p"},"#getKnown*")," methods can be supplied the entries via ",(0,r.kt)("inlineCode",{parentName:"p"},"DeferredRegister#getEntries"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"```java\n// In some BlockLootSubProvider subclass for some DeferredRegister BLOCK_REGISTRAR\n@Override\nprotected Iterable<Block> getKnownBlocks() {\n  return BLOCK_REGISTRAR.getEntries() // Get all registered entries\n    .stream() // Stream the wrapped objects\n    .flatMap(RegistryObject::stream) // Get the object if available\n    ::iterator; // Create the iterable\n}\n```\n")),(0,r.kt)("p",null,"The loot tables themselves can be added by implementing the ",(0,r.kt)("inlineCode",{parentName:"p"},"#generate")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// In some BlockLootSubProvider subclass\n@Override\npublic void generate() {\n  // Add loot tables here\n}\n")),(0,r.kt)("h2",{id:"loot-table-builders"},"Loot Table Builders"),(0,r.kt)("p",null,"To generate loot tables, they are accepted by the ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTableSubProvider")," as a ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTable$Builder"),". Afterwards, the specified ",(0,r.kt)("inlineCode",{parentName:"p"},"LootContextParamSet")," is set in the ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTableProvider$SubProviderEntry")," and then built via ",(0,r.kt)("inlineCode",{parentName:"p"},"#build"),". Before being built, the builder can specify entries, conditions, and modifiers which affect how the loot table functions."),(0,r.kt)("p",null,"!!! note\nThe functionality of loot tables is so expansive that it will not be covered by this documentation in its entirety. Instead, a brief description of each component will be mentioned. The specific subtypes of each component can be found using an IDE. Their implementations will be left as an exercise to the reader."),(0,r.kt)("h3",{id:"loottable"},"LootTable"),(0,r.kt)("p",null,"Loot tables are the base object and can be transformed into the required ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTable$Builder")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"LootTable#lootTable"),". The loot table can be built with a list of pools (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#withPool"),") applied in the order they are specified along with functions (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#apply"),") to modify the resulting items of those pools."),(0,r.kt)("h3",{id:"lootpool"},"LootPool"),(0,r.kt)("p",null,"Loot pools represents a group to perform operations and can generate a  ",(0,r.kt)("inlineCode",{parentName:"p"},"LootPool$Builder")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"LootPool#lootPool"),". Each loot pool can specify the entries (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#add"),") which define the operations in the pool, the conditions (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#when"),") which define if the operations in the pool should be performed, and functions (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#apply"),") to modify the resulting items of the entries. Each pool can be executed as many times as specified (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#setRolls"),"). Additionally, bonus executions can be specified (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#setBonusRolls"),") which is modified by the luck of the executor."),(0,r.kt)("h3",{id:"lootpoolentrycontainer"},"LootPoolEntryContainer"),(0,r.kt)("p",null,"Loot entries define the operations to occur when selected, typically generating items. Each entry has an associated, ",(0,r.kt)("a",{parentName:"p",href:"/docs/concepts/registries#registries-that-arent-forge-registries"},"registered")," ",(0,r.kt)("inlineCode",{parentName:"p"},"LootPoolEntryType"),". They also have their own associated builders which subtype ",(0,r.kt)("inlineCode",{parentName:"p"},"LootPoolEntryContainer$Builder"),". Multiple entries can execute at the same time (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#append"),") or sequentially until one fails (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#then"),"). Additionally, entries can default to another entry on failure (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#otherwise"),")."),(0,r.kt)("h3",{id:"lootitemcondition"},"LootItemCondition"),(0,r.kt)("p",null,"Loot conditions define requirements which need to be met for some operation to execute. Each condition has an associated, ",(0,r.kt)("a",{parentName:"p",href:"/docs/concepts/registries#registries-that-arent-forge-registries"},"registered")," ",(0,r.kt)("inlineCode",{parentName:"p"},"LootItemConditionType"),". They also have their own associated builders which subtype ",(0,r.kt)("inlineCode",{parentName:"p"},"LootItemCondition$Builder"),". By default, all loot conditions specified must return true for an operation to execute. Loot conditions can also be specified such that only one must return true instead (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#or"),"). Additionally, the resulting output of a condition can be inverted (via ",(0,r.kt)("inlineCode",{parentName:"p"},"#invert"),")."),(0,r.kt)("h3",{id:"lootitemfunction"},"LootItemFunction"),(0,r.kt)("p",null,"Loot functions modify the result of an execution before passing it to the output. Each function has an associated, ",(0,r.kt)("a",{parentName:"p",href:"/docs/concepts/registries#registries-that-arent-forge-registries"},"registered")," ",(0,r.kt)("inlineCode",{parentName:"p"},"LootItemFunctionType"),". They also have their own associated builders which subtype ",(0,r.kt)("inlineCode",{parentName:"p"},"LootItemFunction$Builder"),"."),(0,r.kt)("h4",{id:"nbtprovider"},"NbtProvider"),(0,r.kt)("p",null,"NBT providers are a special type of functions defined by ",(0,r.kt)("inlineCode",{parentName:"p"},"CopyNbtFunction"),". They define where to pull tag information from. Each provider has an associated, ",(0,r.kt)("a",{parentName:"p",href:"/docs/concepts/registries#registries-that-arent-forge-registries"},"registered")," ",(0,r.kt)("inlineCode",{parentName:"p"},"LootNbtProviderType"),"."),(0,r.kt)("h3",{id:"numberprovider"},"NumberProvider"),(0,r.kt)("p",null,"Number providers determine how many times a loot pool executes. Each provider has an associated, ",(0,r.kt)("a",{parentName:"p",href:"/docs/concepts/registries#registries-that-arent-forge-registries"},"registered")," ",(0,r.kt)("inlineCode",{parentName:"p"},"LootNumberProviderType"),"."),(0,r.kt)("h4",{id:"scoreboardnameprovider"},"ScoreboardNameProvider"),(0,r.kt)("p",null,"Scoreboard providers are a special type of number providers defined by ",(0,r.kt)("inlineCode",{parentName:"p"},"ScoreboardValue"),". They define the name of the scoreboard to pull the number of rolls to execute from. Each provider has an associated, ",(0,r.kt)("a",{parentName:"p",href:"/docs/concepts/registries#registries-that-arent-forge-registries"},"registered")," ",(0,r.kt)("inlineCode",{parentName:"p"},"LootScoreProviderType"),"."))}u.isMDXComponent=!0}}]);