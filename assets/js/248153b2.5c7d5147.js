"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[4260],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=d(n),u=i,m=h["".concat(l,".").concat(u)]||h[u]||p[u]||r;return n?a.createElement(m,o(o({ref:t},c),{},{components:n})):a.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,o[1]=s;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8603:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));const r={},o="Screens",s={unversionedId:"gui/screens",id:"gui/screens",title:"Screens",description:"Screens are typically the base of all Graphical User Interfaces (GUIs) in Minecraft: taking in user input, verifying it on the server, and syncing the resulting action back to the client. They can be combined with [menus] to create an communication network for inventory-like views, or they can be standalone which modders can handle through their own [network] implementations.",source:"@site/docs/gui/screens.md",sourceDirName:"gui",slug:"/gui/screens",permalink:"/docs/gui/screens",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Menus",permalink:"/docs/gui/menus"},next:{title:"Items",permalink:"/docs/items/"}},l={},d=[{value:"Relative Coordinates",id:"relative-coordinates",level:2},{value:"Gui Graphics",id:"gui-graphics",level:2},{value:"Colored Rectangles",id:"colored-rectangles",level:3},{value:"Strings",id:"strings",level:3},{value:"Textures",id:"textures",level:3},{value:"Blit Offset",id:"blit-offset",level:4},{value:"Renderable",id:"renderable",level:2},{value:"GuiEventListener",id:"guieventlistener",level:2},{value:"ContainerEventHandler",id:"containereventhandler",level:3},{value:"NarratableEntry",id:"narratableentry",level:2},{value:"The Screen Subtype",id:"the-screen-subtype",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Ticking Screens",id:"ticking-screens",level:3},{value:"Input Handling",id:"input-handling",level:3},{value:"Rendering the Screen",id:"rendering-the-screen",level:3},{value:"Closing the Screen",id:"closing-the-screen",level:3},{value:"<code>AbstractContainerScreen</code>",id:"abstractcontainerscreen",level:2},{value:"Menu Access",id:"menu-access",level:3},{value:"Container Tick",id:"container-tick",level:3},{value:"Rendering the Container Screen",id:"rendering-the-container-screen",level:3},{value:"Registering an AbstractContainerScreen",id:"registering-an-abstractcontainerscreen",level:2}],c={toc:d},h="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(h,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"screens"},"Screens"),(0,i.kt)("p",null,"Screens are typically the base of all Graphical User Interfaces (GUIs) in Minecraft: taking in user input, verifying it on the server, and syncing the resulting action back to the client. They can be combined with ",(0,i.kt)("a",{parentName:"p",href:"/docs/gui/menus"},"menus")," to create an communication network for inventory-like views, or they can be standalone which modders can handle through their own ",(0,i.kt)("a",{parentName:"p",href:"/docs/networking/"},"network")," implementations."),(0,i.kt)("p",null,"Screens are made up of numerous parts, making it difficult to fully understand what a 'screen' actually is in Minecraft. As such, this document will go over each of the screen's components and how it is applied before discussing the screen itself."),(0,i.kt)("h2",{id:"relative-coordinates"},"Relative Coordinates"),(0,i.kt)("p",null,"Whenever anything is rendered, there needs to be some identifier which specifies where it will appear. With numerous abstractions, most of Minecraft's rendering calls takes in an x, y, and z value in a coordinate plane. X values increase from left to right, y from top to bottom, and z from far to near. However, the coordinates are not fixed to a specified range. They can change depending on the size of the screen and the scale at which is specified within the options. As such, extra care must be taken to make sure the values of the coordinates while rendering scale properly to the changeable screen size."),(0,i.kt)("p",null,"Information on how to relativize your coordinates will be within the ",(0,i.kt)("a",{parentName:"p",href:"#the-screen-subtype"},"screen")," section."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"If you choose to use fixed coordinates or incorrectly scale the screen, the rendered objects may look strange or misplaced. An easy way to check if you relativized your coordinates correctly is to click the 'Gui Scale' button in your video settings. This value is used as the divisor to the width and height of your display when determining the scale at which a GUI should render.")),(0,i.kt)("h2",{id:"gui-graphics"},"Gui Graphics"),(0,i.kt)("p",null,"Any GUI rendered by Minecraft is typically done using ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiGraphics"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiGraphics")," is the first parameter to almost all rendering methods; it contains basic methods to render commonly used objects. These fall into five categories: colored rectangles, strings, and textures, items, and tooltips. There is also an additional method for rendering a snippet of a component (",(0,i.kt)("inlineCode",{parentName:"p"},"#enableScissor")," / ",(0,i.kt)("inlineCode",{parentName:"p"},"#disableScissor"),"). ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiGraphics")," also exposes the ",(0,i.kt)("inlineCode",{parentName:"p"},"PoseStack")," which applies the transformations necessary to properly render where the component should be rendered. Additionally, colors are in the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/RGBA_color_model#ARGB32"},"ARGB")," format."),(0,i.kt)("h3",{id:"colored-rectangles"},"Colored Rectangles"),(0,i.kt)("p",null,"Colored rectangles are drawn through a position color shader. There are three types of colored rectangles that can be drawn."),(0,i.kt)("p",null,"First, there is a colored horizontal and vertical one-pixel wide line, ",(0,i.kt)("inlineCode",{parentName:"p"},"#hLine")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"#vLine")," respectively. ",(0,i.kt)("inlineCode",{parentName:"p"},"#hLine")," takes in two x coordinates defining the left and right (inclusively), the top y coordinate, and the color. ",(0,i.kt)("inlineCode",{parentName:"p"},"#vLine")," takes in the left x coordinate, two y coordinates defining the top and bottom (inclusively), and the color."),(0,i.kt)("p",null,"Second, there is the ",(0,i.kt)("inlineCode",{parentName:"p"},"#fill")," method, which draws a rectangle to the screen. The line methods internally call this method. This takes in the left x coordinate, the top y coordinate, the right x coordinate, the bottom y coordinate, and the color."),(0,i.kt)("p",null,"Finally, there is the ",(0,i.kt)("inlineCode",{parentName:"p"},"#fillGradient")," method, which draws a rectangle with a vertical gradient. This takes in the right x coordinate, the bottom y coordinate, the left x coordinate, the top y coordinate, the z coordinate, and the bottom and top colors."),(0,i.kt)("h3",{id:"strings"},"Strings"),(0,i.kt)("p",null,"Strings are drawn through its ",(0,i.kt)("inlineCode",{parentName:"p"},"Font"),", typically consisting of their own shaders for normal, see through, and offset mode. There are two alignment of strings that can be rendered, each with a back shadow: a left-aligned string (",(0,i.kt)("inlineCode",{parentName:"p"},"#drawString"),") and a center-aligned string (",(0,i.kt)("inlineCode",{parentName:"p"},"#drawCenteredString"),"). These both take in the font the string will be rendered in, the string to draw, the x coordinate representing the left or center of the string respectively, the top y coordinate, and the color."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Strings should typically be passed in as ",(0,i.kt)("a",{parentName:"p",href:"/docs/concepts/internationalization#translatablecontents"},(0,i.kt)("inlineCode",{parentName:"a"},"Component"),"s")," as they handle a variety of usecases, including the two other overloads of the method.")),(0,i.kt)("h3",{id:"textures"},"Textures"),(0,i.kt)("p",null,"Textures are drawn through blitting, hence the method name ",(0,i.kt)("inlineCode",{parentName:"p"},"#blit"),", which, for this purpose, copies the bits of an image and draws them directly to the screen. These are drawn through a position texture shader. While there are many different ",(0,i.kt)("inlineCode",{parentName:"p"},"#blit")," overloads, we will only discuss two static ",(0,i.kt)("inlineCode",{parentName:"p"},"#blit"),"s."),(0,i.kt)("p",null,"The first static ",(0,i.kt)("inlineCode",{parentName:"p"},"#blit")," takes in six integers and assumes the texture being rendered is on a 256 x 256 PNG file. It takes in the left x and top y screen coordinate, the left x and top y coordinate within the PNG, and the width and height of the image to render."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The size of the PNG file must be specified so that the coordinates can be normalized to obtain the associated UV values.")),(0,i.kt)("p",null,"The static ",(0,i.kt)("inlineCode",{parentName:"p"},"#blit")," which the first calls expands this to nine integers, only assuming the image is on a PNG file. It takes in the left x and top y screen coordinate, the z coordinate (referred to as the blit offset), the left x and top y coordinate within the PNG, the width and height of the image to render, and the width and height of the PNG file."),(0,i.kt)("h4",{id:"blit-offset"},"Blit Offset"),(0,i.kt)("p",null,"The z coordinate when rendering a texture is typically set to the blit offset. The offset is responsible for properly layering renders when viewing a screen. Renders with a smaller z coordinate are rendered in the background and vice versa where renders with a larger z coordinate are rendered in the foreground. The z offset can be set directly on the ",(0,i.kt)("inlineCode",{parentName:"p"},"PoseStack")," itself via ",(0,i.kt)("inlineCode",{parentName:"p"},"#translate"),". Some basic offset logic is applied internally in some methods of ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiGraphics")," (e.g. item rendering)."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"When setting the blit offset, you must reset it after rendering your object. Otherwise, other objects within the screen may be rendered in an incorrect layer causing graphical issues. It is recommended to push the current pose before translating and then popping after all rendering at the offset is completed.")),(0,i.kt)("h2",{id:"renderable"},"Renderable"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Renderable"),"s are essentially objects that are rendered. These include screens, buttons, chat boxes, lists, etc. ",(0,i.kt)("inlineCode",{parentName:"p"},"Renderable"),"s only have one method: ",(0,i.kt)("inlineCode",{parentName:"p"},"#render"),". This takes in the ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiGraphics")," used to render things to the screen, the x and y positions of the mouse scaled to the relative screen size, and the tick delta (how many ticks have passed since the last frame)."),(0,i.kt)("p",null,"Some common renderables are screens and 'widgets': interactable elements which typically render on the screen such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Button"),", its subtype ",(0,i.kt)("inlineCode",{parentName:"p"},"ImageButton"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"EditBox")," which is used to input text on the screen."),(0,i.kt)("h2",{id:"guieventlistener"},"GuiEventListener"),(0,i.kt)("p",null,"Any screen rendered in Minecraft implements ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiEventListener"),". ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiEventListener"),"s are responsible for handling user interaction with the screen. These include inputs from the mouse (movement, clicked, released, dragged, scrolled, mouseover) and keyboard (pressed, released, typed). Each method returns whether the associated action affected the screen successfully. Widgets like buttons, chat boxes, lists, etc. also implement this interface."),(0,i.kt)("h3",{id:"containereventhandler"},"ContainerEventHandler"),(0,i.kt)("p",null,"Almost synonymous with ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiEventListener"),"s are their subtype: ",(0,i.kt)("inlineCode",{parentName:"p"},"ContainerEventHandler"),"s. These are responsible for handling user interaction on screens which contain widgets, managing which is currently focused and how the associated interactions are applied. ",(0,i.kt)("inlineCode",{parentName:"p"},"ContainerEventHandler"),"s add three additional features: interactable children, dragging, and focusing."),(0,i.kt)("p",null,"Event handlers hold children which are used to determine the interaction order of elements. During the mouse event handlers (excluding dragging), the first child in the list that the mouse hovers over has their logic executed."),(0,i.kt)("p",null,"Dragging an element with the mouse, implemented via ",(0,i.kt)("inlineCode",{parentName:"p"},"#mouseClicked")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"#mouseReleased"),", provides more precisely executed logic."),(0,i.kt)("p",null,"Focusing allows for a specific child to be checked first and handled during an event's execution, such as during keyboard events or dragging the mouse. Focus is typically set through ",(0,i.kt)("inlineCode",{parentName:"p"},"#setFocused"),". In addition, interactable children can be cycled using ",(0,i.kt)("inlineCode",{parentName:"p"},"#nextFocusPath"),", selecting the child based upon the ",(0,i.kt)("inlineCode",{parentName:"p"},"FocusNavigationEvent")," passed in."),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"Screens implement ",(0,i.kt)("inlineCode",{parentName:"p"},"ContainerEventHandler")," through ",(0,i.kt)("inlineCode",{parentName:"p"},"AbstractContainerEventHandler"),", which adds in the setter and getter logic for dragging and focusing children.")),(0,i.kt)("h2",{id:"narratableentry"},"NarratableEntry"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"NarratableEntry"),"s are elements which can be spoken about through Minecraft's accessibility narration feature. Each element can provide different narration depending on what is hovered or selected, prioritized typically by focus, hovering, and then all other cases."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"NarratableEntry"),"s have three methods: one which determines the priority of the element (",(0,i.kt)("inlineCode",{parentName:"p"},"#narrationPriority"),"), one which determines whether to speak the narration (",(0,i.kt)("inlineCode",{parentName:"p"},"#isActive"),"), and finally one which supplies the narration to its associated output, spoken or read (",(0,i.kt)("inlineCode",{parentName:"p"},"#updateNarration"),"). "),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"All widgets from Minecraft are ",(0,i.kt)("inlineCode",{parentName:"p"},"NarratableEntry"),"s, so it typically does not need to be manually implemented if using an available subtype.")),(0,i.kt)("h2",{id:"the-screen-subtype"},"The Screen Subtype"),(0,i.kt)("p",null,"With all of the above knowledge, a basic screen can be constructed. To make it easier to understand, the components of a screen will be mentioned in the order they are typically encountered."),(0,i.kt)("p",null,"First, all screens take in a ",(0,i.kt)("inlineCode",{parentName:"p"},"Component")," which represents the title of the screen. This component is typically drawn to the screen by one of its subtypes. It is only used in the base screen for the narration message."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some Screen subclass\npublic MyScreen(Component title) {\n    super(title);\n}\n")),(0,i.kt)("h3",{id:"initialization"},"Initialization"),(0,i.kt)("p",null,"Once a screen has been initialized, the ",(0,i.kt)("inlineCode",{parentName:"p"},"#init")," method is called. The ",(0,i.kt)("inlineCode",{parentName:"p"},"#init")," method sets the initial settings inside the screen from the ",(0,i.kt)("inlineCode",{parentName:"p"},"ItemRenderer")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Minecraft")," instance to the relative width and height as scaled by the game. Any setup such as adding widgets or precomputing relative coordinates should be done in this method. If the game window is resized, the screen will be reinitialized by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"#init")," method."),(0,i.kt)("p",null,"There are three ways to add a widget to a screen, each serving a separate purpose:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Method"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"#addWidget")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Adds a widget that is interactable and narrated, but not rendered.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"#addRenderableOnly")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Adds a widget that will only be rendered; it is not interactable or narrated.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"#addRenderableWidget")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Adds a widget that is interactable, narrated, and rendered.")))),(0,i.kt)("p",null,"Typically, ",(0,i.kt)("inlineCode",{parentName:"p"},"#addRenderableWidget")," will be used most often."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some Screen subclass\n@Override\nprotected void init() {\n    super.init();\n\n    // Add widgets and precomputed values\n    this.addRenderableWidget(new EditBox(/* ... */));\n}\n")),(0,i.kt)("h3",{id:"ticking-screens"},"Ticking Screens"),(0,i.kt)("p",null,"Screens also tick using the ",(0,i.kt)("inlineCode",{parentName:"p"},"#tick")," method to perform some level of client side logic for rendering purposes. The most common example is the ",(0,i.kt)("inlineCode",{parentName:"p"},"EditBox")," for the blinking cursor."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some Screen subclass\n@Override\npublic void tick() {\n    super.tick();\n\n    // Add ticking logic for EditBox in editBox\n    this.editBox.tick();\n}\n")),(0,i.kt)("h3",{id:"input-handling"},"Input Handling"),(0,i.kt)("p",null,"Since screens are subtypes of ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiEventListener"),"s, the input handlers can also be overridden, such as for handling logic on a specific ",(0,i.kt)("a",{parentName:"p",href:"/docs/misc/keymappings#inside-a-gui"},"key press"),"."),(0,i.kt)("h3",{id:"rendering-the-screen"},"Rendering the Screen"),(0,i.kt)("p",null,"Finally, screens are rendered through the ",(0,i.kt)("inlineCode",{parentName:"p"},"#render")," method provided by being a ",(0,i.kt)("inlineCode",{parentName:"p"},"Renderable")," subtype. As mentioned, the ",(0,i.kt)("inlineCode",{parentName:"p"},"#render")," method draws the everything the screen has to render every frame, such as the background, widgets, tooltips, etc. By default, the ",(0,i.kt)("inlineCode",{parentName:"p"},"#render")," method only renders the widgets to the screen."),(0,i.kt)("p",null,"The two most common things rendered within a screen that is typically not handled by a subtype is the background and the tooltips."),(0,i.kt)("p",null,"The background can be rendered using ",(0,i.kt)("inlineCode",{parentName:"p"},"#renderBackground"),", with one method taking in a v Offset for the options background whenever a screen is rendered when the level behind it cannot be."),(0,i.kt)("p",null,"Tooltips are rendered through ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiGraphics#renderTooltip")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"GuiGraphics#renderComponentTooltip")," which can take in the text components being rendered, an optional custom tooltip component, and the x / y relative coordinates on where the tooltip should be rendered on the screen."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some Screen subclass\n\n// mouseX and mouseY indicate the scaled coordinates of where the cursor is in on the screen\n@Override\npublic void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTick) {\n    // Background is typically rendered first\n    this.renderBackground(graphics);\n\n    // Render things here before widgets (background textures)\n\n    // Then the widgets if this is a direct child of the Screen\n    super.render(graphics, mouseX, mouseY, partialTick);\n\n    // Render things after widgets (tooltips)\n}\n")),(0,i.kt)("h3",{id:"closing-the-screen"},"Closing the Screen"),(0,i.kt)("p",null,"When a screen is closed, two methods handle the teardown: ",(0,i.kt)("inlineCode",{parentName:"p"},"#onClose")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"#removed"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"#onClose")," is called whenever the user makes an input to close the current screen. This method is typically used as a callback to destroy and save any internal processes in the screen itself. This includes sending packets to the server."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"#removed")," is called just before the screen changes and is released to the garbage collector. This handles anything that hasn't been reset back to its initial state before the screen was opened."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some Screen subclass\n\n@Override\npublic void onClose() {\n    // Stop any handlers here\n\n    // Call last in case it interferes with the override\n    super.onClose();\n}\n\n@Override\npublic void removed() {\n    // Reset initial states here\n\n    // Call last in case it interferes with the override\n    super.removed()\n;}\n")),(0,i.kt)("h2",{id:"abstractcontainerscreen"},(0,i.kt)("inlineCode",{parentName:"h2"},"AbstractContainerScreen")),(0,i.kt)("p",null,"If a screen is directly attached to a ",(0,i.kt)("a",{parentName:"p",href:"/docs/gui/menus"},"menu"),", then an ",(0,i.kt)("inlineCode",{parentName:"p"},"AbstractContainerScreen")," should be subclassed instead. An ",(0,i.kt)("inlineCode",{parentName:"p"},"AbstractContainerScreen")," acts as the renderer and input handler of a menu and contains logic for syncing and interacting with slots. As such, only two methods typically need to be overridden or implemented to have a working container screen. Once again, to make it easier to understand, the components of a container screen will be mentioned in the order they are typically encountered."),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"AbstractContainerScreen")," typically requires three parameters: the container menu being opened (represented by the generic ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),"), the player inventory (only for the display name), and the title of the screen itself. Within here, a number of positioning fields can be set:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"Field"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"imageWidth")),(0,i.kt)("td",{parentName:"tr",align:"left"},"The width of the texture used for the background. This is typically inside a PNG of 256 x 256 and defaults to 176.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"imageHeight")),(0,i.kt)("td",{parentName:"tr",align:"left"},"The width of the texture used for the background. This is typically inside a PNG of 256 x 256 and defaults to 166.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"titleLabelX")),(0,i.kt)("td",{parentName:"tr",align:"left"},"The relative x coordinate of where the screen title will be rendered.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"titleLabelY")),(0,i.kt)("td",{parentName:"tr",align:"left"},"The relative y coordinate of where the screen title will be rendered.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"inventoryLabelX")),(0,i.kt)("td",{parentName:"tr",align:"left"},"The relative x coordinate of where the player inventory name will be rendered.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("inlineCode",{parentName:"td"},"inventoryLabelY")),(0,i.kt)("td",{parentName:"tr",align:"left"},"The relative y coordinate of where the player inventory name will be rendered.")))),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"In a previous section, it mentioned that precomputed relative coordinates should be set in the ",(0,i.kt)("inlineCode",{parentName:"p"},"#init")," method. This still remains true, as the values mentioned here are not precomputed coordinates but static values and relativized coordinates."),(0,i.kt)("p",{parentName:"admonition"},"The image values are static and non changing as they represent the background texture size. To make things easier when rendering, two additional values (",(0,i.kt)("inlineCode",{parentName:"p"},"leftPos")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"topPos"),") are precomputed in the ",(0,i.kt)("inlineCode",{parentName:"p"},"#init")," method which marks the top left corner of where the background will be rendered. The label coordinates are relative to these values."),(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"leftPos")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"topPos")," is also used as a convenient way to render the background as they already represent the position to pass into the ",(0,i.kt)("inlineCode",{parentName:"p"},"#blit")," method.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some AbstractContainerScreen subclass\npublic MyContainerScreen(MyMenu menu, Inventory playerInventory, Component title) {\n    super(menu, playerInventory, title);\n\n    this.titleLabelX = 10;\n    this.inventoryLabelX = 10;\n\n    /*\n     * If the 'imageHeight' is changed, 'inventoryLabelY' must also be\n     * changed as the value depends on the 'imageHeight' value.\n     */\n}\n")),(0,i.kt)("h3",{id:"menu-access"},"Menu Access"),(0,i.kt)("p",null,"As the menu is passed into the screen, any values that were within the menu and synced (either through slots, data slots, or a custom system) can now be accessed through the ",(0,i.kt)("inlineCode",{parentName:"p"},"menu")," field."),(0,i.kt)("h3",{id:"container-tick"},"Container Tick"),(0,i.kt)("p",null,"Container screens tick within the ",(0,i.kt)("inlineCode",{parentName:"p"},"#tick")," method when the player is alive and looking at the screen via ",(0,i.kt)("inlineCode",{parentName:"p"},"#containerTick"),". This essentially takes the place of ",(0,i.kt)("inlineCode",{parentName:"p"},"#tick")," within container screens, with its most common usage being to tick the recipe book."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some AbstractContainerScreen subclass\n@Override\nprotected void containerTick() {\n    super.containerTick();\n\n    // Tick things here\n}\n")),(0,i.kt)("h3",{id:"rendering-the-container-screen"},"Rendering the Container Screen"),(0,i.kt)("p",null,"The container screen is rendered across three methods: ",(0,i.kt)("inlineCode",{parentName:"p"},"#renderBg"),", which renders the background textures, ",(0,i.kt)("inlineCode",{parentName:"p"},"#renderLabels"),", which renders any text on top of the background, and ",(0,i.kt)("inlineCode",{parentName:"p"},"#render")," which encompass the previous two methods in addition to providing a grayed out background and tooltips."),(0,i.kt)("p",null,"Starting with ",(0,i.kt)("inlineCode",{parentName:"p"},"#render"),", the most common override (and typically the only case) adds the background, calls the super to render the container screen, and finally renders the tooltips on top of it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some AbstractContainerScreen subclass\n@Override\npublic void render(GuiGraphics graphics, int mouseX, int mouseY, float partialTick) {\n    this.renderBackground(graphics);\n    super.render(graphics, mouseX, mouseY, partialTick);\n\n    /*\n     * This method is added by the container screen to render\n     * the tooltip of the hovered slot.\n     */\n    this.renderTooltip(graphics, mouseX, mouseY);\n}\n")),(0,i.kt)("p",null,"Within the super, ",(0,i.kt)("inlineCode",{parentName:"p"},"#renderBg")," is called to render the background of the screen. The most standard representation uses three method calls: two for setup and one to draw the background texture."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some AbstractContainerScreen subclass\n\n// The location of the background texture (assets/<namespace>/<path>)\nprivate static final ResourceLocation BACKGROUND_LOCATION = new ResourceLocation(MOD_ID, \"textures/gui/container/my_container_screen.png\");\n\n@Override\nprotected void renderBg(GuiGraphics graphics, float partialTick, int mouseX, int mouseY) {\n    /*\n     * Sets the texture location for the shader to use. While up to\n     * 12 textures can be set, the shader used within 'blit' only\n     * looks at the first texture index.\n     */\n    RenderSystem.setShaderTexture(0, BACKGROUND_LOCATION);\n\n    /*\n     * Renders the background texture to the screen. 'leftPos' and\n     * 'topPos' should already represent the top left corner of where\n     * the texture should be rendered as it was precomputed from the\n     * 'imageWidth' and 'imageHeight'. The two zeros represent the\n     * integer u/v coordinates inside the 256 x 256 PNG file.\n     */\n    graphics.blit(BACKGROUND_LOCATION, this.leftPos, this.topPos, 0, 0, this.imageWidth, this.imageHeight);\n}\n")),(0,i.kt)("p",null,"Finally, ",(0,i.kt)("inlineCode",{parentName:"p"},"#renderLabels")," is called to render any text above the background, but below the tooltips. This simply calls uses the font to draw the associated components."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In some AbstractContainerScreen subclass\n@Override\nprotected void renderLabels(GuiGraphics graphics, int mouseX, int mouseY) {\n    super.renderLabels(graphics, mouseX, mouseY);\n\n    // Assume we have some Component 'label'\n    // 'label' is drawn at 'labelX' and 'labelY'\n    graphics.drawString(this.font, this.label, this.labelX, this.labelY, 0x404040);\n}\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"When rendering the label, you do ",(0,i.kt)("strong",{parentName:"p"},"not")," need to specify the ",(0,i.kt)("inlineCode",{parentName:"p"},"leftPos")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"topPos")," offset. Those have already been translated within the ",(0,i.kt)("inlineCode",{parentName:"p"},"PoseStack")," so everything within this method is drawn relative to those coordinates.")),(0,i.kt)("h2",{id:"registering-an-abstractcontainerscreen"},"Registering an AbstractContainerScreen"),(0,i.kt)("p",null,"To use an ",(0,i.kt)("inlineCode",{parentName:"p"},"AbstractContainerScreen")," with a menu, it needs to be registered. This can be done by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"MenuScreens#register")," within the ",(0,i.kt)("inlineCode",{parentName:"p"},"FMLClientSetupEvent")," on the ",(0,i.kt)("a",{parentName:"p",href:"/docs/concepts/events#mod-event-bus"},(0,i.kt)("strong",{parentName:"a"},"mod event bus")),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// Event is listened to on the mod event bus\nprivate void clientSetup(FMLClientSetupEvent event) {\n    event.enqueueWork(\n        // Assume RegistryObject<MenuType<MyMenu>> MY_MENU\n        // Assume MyContainerScreen<MyMenu> which takes in three parameters\n        () -> MenuScreens.register(MY_MENU.get(), MyContainerScreen::new)\n    );\n}\n")),(0,i.kt)("admonition",{type:"danger"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"MenuScreens#register")," is not thread-safe, so it needs to be called inside ",(0,i.kt)("inlineCode",{parentName:"p"},"#enqueueWork")," provided by the parallel dispatch event.")))}p.isMDXComponent=!0}}]);