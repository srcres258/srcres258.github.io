"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[7462],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,u=d["".concat(l,".").concat(m)]||d[m]||h[m]||r;return n?a.createElement(u,o(o({ref:t},p),{},{components:n})):a.createElement(u,o({ref:t},p))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1684:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const r={},o="SimpleImpl",s={unversionedId:"networking/simpleimpl",id:"networking/simpleimpl",title:"SimpleImpl",description:"SimpleImpl is the name given to the packet system that revolves around the SimpleChannel class. Using this system is by far the easiest way to send custom data between clients and the server.",source:"@site/docs/networking/simpleimpl.md",sourceDirName:"networking",slug:"/networking/simpleimpl",permalink:"/docs/networking/simpleimpl",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Entities",permalink:"/docs/networking/entities"},next:{title:"Face Data",permalink:"/docs/rendering/modelextensions/facedata"}},l={},c=[{value:"Getting Started",id:"getting-started",level:2},{value:"The Version Checker",id:"the-version-checker",level:2},{value:"Registering Packets",id:"registering-packets",level:2},{value:"Handling Packets",id:"handling-packets",level:2},{value:"Sending Packets",id:"sending-packets",level:2},{value:"Sending to the Server",id:"sending-to-the-server",level:3},{value:"Sending to Clients",id:"sending-to-clients",level:3}],p={toc:c},d="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"simpleimpl"},"SimpleImpl"),(0,i.kt)("p",null,"SimpleImpl is the name given to the packet system that revolves around the ",(0,i.kt)("inlineCode",{parentName:"p"},"SimpleChannel")," class. Using this system is by far the easiest way to send custom data between clients and the server."),(0,i.kt)("h2",{id:"getting-started"},"Getting Started"),(0,i.kt)("p",null,"First you need to create your ",(0,i.kt)("inlineCode",{parentName:"p"},"SimpleChannel")," object. We recommend that you do this in a separate class, possibly something like ",(0,i.kt)("inlineCode",{parentName:"p"},"ModidPacketHandler"),". Create your ",(0,i.kt)("inlineCode",{parentName:"p"},"SimpleChannel")," as a static field in this class, like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'private static final String PROTOCOL_VERSION = "1";\npublic static final SimpleChannel INSTANCE = NetworkRegistry.newSimpleChannel(\n  new ResourceLocation("mymodid", "main"),\n  () -> PROTOCOL_VERSION,\n  PROTOCOL_VERSION::equals,\n  PROTOCOL_VERSION::equals\n);\n')),(0,i.kt)("p",null,"The first argument is a name for the channel. The second argument is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Supplier<String>")," returning the current network protocol version. The third and fourth arguments respectively are ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate<String>")," checking whether an incoming connection protocol version is network-compatible with the client or server, respectively.\nHere, we simply compare with the ",(0,i.kt)("inlineCode",{parentName:"p"},"PROTOCOL_VERSION")," field directly, meaning that the client and server ",(0,i.kt)("inlineCode",{parentName:"p"},"PROTOCOL_VERSION"),"s must always match or FML will deny login."),(0,i.kt)("h2",{id:"the-version-checker"},"The Version Checker"),(0,i.kt)("p",null,"If your mod does not require the other side to have a specific network channel, or to be a Forge instance at all, you should take care that you properly define your version compatibility checkers (the ",(0,i.kt)("inlineCode",{parentName:"p"},"Predicate<String>"),' parameters) to handle additional "meta-versions" (defined in ',(0,i.kt)("inlineCode",{parentName:"p"},"NetworkRegistry"),") that can be received by the version checker. These are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ABSENT")," - if this channel is missing on the other endpoint. Note that in this case, the endpoint is still a Forge endpoint, and may have other mods."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ACCEPTVANILLA")," - if the endpoint is a vanilla (or non-Forge) endpoint.")),(0,i.kt)("p",null,"Returning ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," for both means that this channel must be present on the other endpoint. If you just copy the code above, this is what it does. Note that these values are also used during the list ping compatibility check, which is responsible for showing the green check / red cross in the multiplayer server select screen."),(0,i.kt)("h2",{id:"registering-packets"},"Registering Packets"),(0,i.kt)("p",null,"Next, we must declare the types of messages that we would like to send and receive. This is done using ",(0,i.kt)("inlineCode",{parentName:"p"},"INSTANCE#registerMessage"),", which takes 5 parameters:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The first parameter is the discriminator for the packet. This is a per-channel unique ID for the packet. We recommend you use a local variable to hold the ID, and then call registerMessage using ",(0,i.kt)("inlineCode",{parentName:"li"},"id++"),". This will guarantee 100% unique IDs."),(0,i.kt)("li",{parentName:"ul"},"The second parameter is the actual packet class ",(0,i.kt)("inlineCode",{parentName:"li"},"MSG"),"."),(0,i.kt)("li",{parentName:"ul"},"The third parameter is a ",(0,i.kt)("inlineCode",{parentName:"li"},"BiConsumer<MSG, FriendlyByteBuf>")," responsible for encoding the message into the provided ",(0,i.kt)("inlineCode",{parentName:"li"},"FriendlyByteBuf"),"."),(0,i.kt)("li",{parentName:"ul"},"The fourth parameter is a ",(0,i.kt)("inlineCode",{parentName:"li"},"Function<FriendlyByteBuf, MSG>")," responsible for decoding the message from the provided ",(0,i.kt)("inlineCode",{parentName:"li"},"FriendlyByteBuf"),"."),(0,i.kt)("li",{parentName:"ul"},"The final parameter is a ",(0,i.kt)("inlineCode",{parentName:"li"},"BiConsumer<MSG, Supplier<NetworkEvent.Context>>")," responsible for handling the message itself.")),(0,i.kt)("p",null,"The last three parameters can be method references to either static or instance methods in Java. Remember that an instance method ",(0,i.kt)("inlineCode",{parentName:"p"},"MSG#encode(FriendlyByteBuf)")," still satisfies ",(0,i.kt)("inlineCode",{parentName:"p"},"BiConsumer<MSG, FriendlyByteBuf>"),"; the ",(0,i.kt)("inlineCode",{parentName:"p"},"MSG")," simply becomes the implicit first argument."),(0,i.kt)("h2",{id:"handling-packets"},"Handling Packets"),(0,i.kt)("p",null,"There are a couple things to highlight in a packet handler. A packet handler has both the message object and the network context available to it. The context allows access to the player that sent the packet (if on the server), and a way to enqueue thread-safe work."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public static void handle(MyMessage msg, Supplier<NetworkEvent.Context> ctx) {\n  ctx.get().enqueueWork(() -> {\n    // Work that needs to be thread-safe (most work)\n    ServerPlayer sender = ctx.get().getSender(); // the client that sent this packet\n    // Do stuff\n  });\n  ctx.get().setPacketHandled(true);\n}\n")),(0,i.kt)("p",null,"Packets sent from the server to the client should be handled in another class and wrapped via ",(0,i.kt)("inlineCode",{parentName:"p"},"DistExecutor#unsafeRunWhenOn"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// In Packet class\npublic static void handle(MyClientMessage msg, Supplier<NetworkEvent.Context> ctx) {\n  ctx.get().enqueueWork(() ->\n    // Make sure it's only executed on the physical client\n    DistExecutor.unsafeRunWhenOn(Dist.CLIENT, () -> () -> ClientPacketHandlerClass.handlePacket(msg, ctx))\n  );\n  ctx.get().setPacketHandled(true);\n}\n\n// In ClientPacketHandlerClass\npublic static void handlePacket(MyClientMessage msg, Supplier<NetworkEvent.Context> ctx) {\n  // Do stuff\n}\n")),(0,i.kt)("p",null,"Note the presence of ",(0,i.kt)("inlineCode",{parentName:"p"},"#setPacketHandled"),", which is used to tell the network system that the packet has successfully completed handling."),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"As of Minecraft 1.8 packets are by default handled on the network thread."),(0,i.kt)("p",{parentName:"admonition"},"That means that your handler can ",(0,i.kt)("em",{parentName:"p"},"not")," interact with most game objects directly. Forge provides a convenient way to make your code execute on the main thread instead through the supplied ",(0,i.kt)("inlineCode",{parentName:"p"},"NetworkEvent$Context"),". Simply call ",(0,i.kt)("inlineCode",{parentName:"p"},"NetworkEvent$Context#enqueueWork(Runnable)"),", which will call the given ",(0,i.kt)("inlineCode",{parentName:"p"},"Runnable")," on the main thread at the next opportunity.")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Be defensive when handling packets on the server. A client could attempt to exploit the packet handling by sending unexpected data."),(0,i.kt)("p",{parentName:"admonition"},"A common problem is vulnerability to ",(0,i.kt)("strong",{parentName:"p"},"arbitrary chunk generation"),". This typically happens when the server is trusting a block position sent by a client to access blocks and block entities. When accessing blocks and block entities in unloaded areas of the level, the server will either generate or load this area from disk, then promptly write it to disk. This can be exploited to cause ",(0,i.kt)("strong",{parentName:"p"},"catastrophic damage")," to a server's performance and storage space without leaving a trace."),(0,i.kt)("p",{parentName:"admonition"},"To avoid this problem, a general rule of thumb is to only access blocks and block entities if ",(0,i.kt)("inlineCode",{parentName:"p"},"Level#hasChunkAt")," is true.")),(0,i.kt)("h2",{id:"sending-packets"},"Sending Packets"),(0,i.kt)("h3",{id:"sending-to-the-server"},"Sending to the Server"),(0,i.kt)("p",null,"There is but one way to send a packet to the server. This is because there is only ever ",(0,i.kt)("em",{parentName:"p"},"one")," server the client can be connected to at once. To do so, we must again use that ",(0,i.kt)("inlineCode",{parentName:"p"},"SimpleChannel")," that was defined earlier. Simply call ",(0,i.kt)("inlineCode",{parentName:"p"},"INSTANCE.sendToServer(new MyMessage())"),". The message will be sent to the handler for its type, if one exists."),(0,i.kt)("h3",{id:"sending-to-clients"},"Sending to Clients"),(0,i.kt)("p",null,"Packets can be sent directly to a client using the ",(0,i.kt)("inlineCode",{parentName:"p"},"SimpleChannel"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"HANDLER.sendTo(new MyClientMessage(), serverPlayer.connection.getConnection(), NetworkDirection.PLAY_TO_CLIENT)"),". However, this can be quite inconvenient. Forge has some convenience functions that can be used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// Send to one player\nINSTANCE.send(PacketDistributor.PLAYER.with(serverPlayer), new MyMessage());\n\n// Send to all players tracking this level chunk\nINSTANCE.send(PacketDistributor.TRACKING_CHUNK.with(levelChunk), new MyMessage());\n\n// Send to all connected players\nINSTANCE.send(PacketDistributor.ALL.noArg(), new MyMessage());\n")),(0,i.kt)("p",null,"There are additional ",(0,i.kt)("inlineCode",{parentName:"p"},"PacketDistributor")," types available; check the documentation on the ",(0,i.kt)("inlineCode",{parentName:"p"},"PacketDistributor")," class for more details."))}h.isMDXComponent=!0}}]);