"use strict";(self.webpackChunkneoforged_docs=self.webpackChunkneoforged_docs||[]).push([[3395],{3905:(e,i,n)=>{n.d(i,{Zo:()=>c,kt:()=>h});var t=n(7294);function r(e,i,n){return i in e?Object.defineProperty(e,i,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[i]=n,e}function a(e,i){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);i&&(t=t.filter((function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),n.push.apply(n,t)}return n}function l(e){for(var i=1;i<arguments.length;i++){var n=null!=arguments[i]?arguments[i]:{};i%2?a(Object(n),!0).forEach((function(i){r(e,i,n[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(n,i))}))}return e}function d(e,i){if(null==e)return{};var n,t,r=function(e,i){if(null==e)return{};var n,t,r={},a=Object.keys(e);for(t=0;t<a.length;t++)n=a[t],i.indexOf(n)>=0||(r[n]=e[n]);return r}(e,i);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)n=a[t],i.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=t.createContext({}),p=function(e){var i=t.useContext(o),n=i;return e&&(n="function"==typeof e?e(i):l(l({},i),e)),n},c=function(e){var i=p(e.components);return t.createElement(o.Provider,{value:i},e.children)},s="mdxType",u={inlineCode:"code",wrapper:function(e){var i=e.children;return t.createElement(t.Fragment,{},i)}},m=t.forwardRef((function(e,i){var n=e.components,r=e.mdxType,a=e.originalType,o=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),s=p(n),m=r,h=s["".concat(o,".").concat(m)]||s[m]||u[m]||a;return n?t.createElement(h,l(l({ref:i},c),{},{components:n})):t.createElement(h,l({ref:i},c))}));function h(e,i){var n=arguments,r=i&&i.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=m;var d={};for(var o in i)hasOwnProperty.call(i,o)&&(d[o]=i[o]);d.originalType=e,d[s]="string"==typeof e?e:r,l[1]=d;for(var p=2;p<a;p++)l[p]=n[p];return t.createElement.apply(null,l)}return t.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9529:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>d,toc:()=>p});var t=n(7462),r=(n(7294),n(3905));const a={},l="Recipe Generation",d={unversionedId:"datagen/server/recipes",id:"datagen/server/recipes",title:"Recipe Generation",description:"Recipes can be generated for a mod by subclassing RecipeProvider and implementing #buildRecipes. A recipe is supplied for data generation once a FinishedRecipe view is accepted by the consumer. FinishedRecipes can either be created and supplied manually or, for convenience, created using a RecipeBuilder.",source:"@site/docs/datagen/server/recipes.md",sourceDirName:"datagen/server",slug:"/datagen/server/recipes",permalink:"/docs/datagen/server/recipes",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"mainSidebar",previous:{title:"Loot Table Generation",permalink:"/docs/datagen/server/loottables"},next:{title:"Tag Generation",permalink:"/docs/datagen/server/tags"}},o={},p=[{value:"<code>RecipeBuilder</code>",id:"recipebuilder",level:2},{value:"ShapedRecipeBuilder",id:"shapedrecipebuilder",level:3},{value:"Additional Validation Checks",id:"additional-validation-checks",level:4},{value:"ShapelessRecipeBuilder",id:"shapelessrecipebuilder",level:3},{value:"SimpleCookingRecipeBuilder",id:"simplecookingrecipebuilder",level:3},{value:"SingleItemRecipeBuilder",id:"singleitemrecipebuilder",level:3},{value:"Non-<code>RecipeBuilder</code> Builders",id:"non-recipebuilder-builders",level:2},{value:"SmithingTransformRecipeBuilder",id:"smithingtransformrecipebuilder",level:3},{value:"SmithingTrimRecipeBuilder",id:"smithingtrimrecipebuilder",level:3},{value:"SpecialRecipeBuilder",id:"specialrecipebuilder",level:3},{value:"Conditional Recipes",id:"conditional-recipes",level:2},{value:"IConditionBuilder",id:"iconditionbuilder",level:3},{value:"Custom Recipe Serializers",id:"custom-recipe-serializers",level:2}],c={toc:p},s="wrapper";function u(e){let{components:i,...n}=e;return(0,r.kt)(s,(0,t.Z)({},c,n,{components:i,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"recipe-generation"},"Recipe Generation"),(0,r.kt)("p",null,"Recipes can be generated for a mod by subclassing ",(0,r.kt)("inlineCode",{parentName:"p"},"RecipeProvider")," and implementing ",(0,r.kt)("inlineCode",{parentName:"p"},"#buildRecipes"),". A recipe is supplied for data generation once a ",(0,r.kt)("inlineCode",{parentName:"p"},"FinishedRecipe")," view is accepted by the consumer. ",(0,r.kt)("inlineCode",{parentName:"p"},"FinishedRecipe"),"s can either be created and supplied manually or, for convenience, created using a ",(0,r.kt)("inlineCode",{parentName:"p"},"RecipeBuilder"),"."),(0,r.kt)("p",null,"After implementation, the provider must be ",(0,r.kt)("a",{parentName:"p",href:"/docs/datagen/#data-providers"},"added")," to the ",(0,r.kt)("inlineCode",{parentName:"p"},"DataGenerator"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// On the MOD event bus\n@SubscribeEvent\npublic void gatherData(GatherDataEvent event) {\n    event.getGenerator().addProvider(\n        // Tell generator to run only when server data are generating\n        event.includeServer(),\n        MyRecipeProvider::new\n    );\n}\n")),(0,r.kt)("h2",{id:"recipebuilder"},(0,r.kt)("inlineCode",{parentName:"h2"},"RecipeBuilder")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RecipeBuilder")," is a convenience implementation for creating ",(0,r.kt)("inlineCode",{parentName:"p"},"FinishedRecipe"),"s to generate. It provides basic definitions for unlocking, grouping, saving, and getting the result of a recipe. This is done through ",(0,r.kt)("inlineCode",{parentName:"p"},"#unlockedBy"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#group"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#save"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"#getResult")," respectively."),(0,r.kt)("p",null,"!!! important\n",(0,r.kt)("a",{parentName:"p",href:"/docs/resources/server/recipes/#recipe-itemstack-result"},(0,r.kt)("inlineCode",{parentName:"a"},"ItemStack")," outputs")," in recipes are not supported within vanilla recipe builders. A ",(0,r.kt)("inlineCode",{parentName:"p"},"FinishedRecipe")," must be built in a different manner for existing vanilla recipe serializers to generate this data."),(0,r.kt)("p",null,"!!! warning\nThe item results being generated must have a valid ",(0,r.kt)("inlineCode",{parentName:"p"},"RecipeCategory")," specified; otherwise, a ",(0,r.kt)("inlineCode",{parentName:"p"},"NullPointerException")," will be thrown."),(0,r.kt)("p",null,"All recipe builders except for ","[",(0,r.kt)("inlineCode",{parentName:"p"},"SpecialRecipeBuilder"),"]"," require an advancement criteria to be specified. All recipes generate a criteria unlocking the recipe if the player has used the recipe previously. However, an additional criteria must be specified that allows the player to obtain the recipe without any prior knowledge. If any of the criteria specified is true, then the played will obtain the recipe for the recipe book."),(0,r.kt)("p",null,"!!! tip\nRecipe criteria commonly use ",(0,r.kt)("inlineCode",{parentName:"p"},"InventoryChangeTrigger")," to unlock their recipe when certain items are present in the user's inventory."),(0,r.kt)("h3",{id:"shapedrecipebuilder"},"ShapedRecipeBuilder"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShapedRecipeBuilder")," is used to generate shaped recipes. The builder can be initialized via ",(0,r.kt)("inlineCode",{parentName:"p"},"#shaped"),". The recipe group, input symbol pattern, symbol definition of ingredients, and the recipe unlock criteria can be specified before saving."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// In RecipeProvider#buildRecipes(writer)\nShapedRecipeBuilder builder = ShapedRecipeBuilder.shaped(RecipeCategory.MISC, result)\n  .pattern("a a") // Create recipe pattern\n  .define(\'a\', item) // Define what the symbol represents\n  .unlockedBy("criteria", criteria) // How the recipe is unlocked\n  .save(writer); // Add data to builder\n')),(0,r.kt)("h4",{id:"additional-validation-checks"},"Additional Validation Checks"),(0,r.kt)("p",null,"Shaped recipes have some additional validation checks performed before building:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A pattern must be defined and take in more than one item."),(0,r.kt)("li",{parentName:"ul"},"All pattern rows must be the same width."),(0,r.kt)("li",{parentName:"ul"},"A symbol cannot be defined more than once."),(0,r.kt)("li",{parentName:"ul"},"The space character (",(0,r.kt)("inlineCode",{parentName:"li"},"' '"),") is reserved for representing no item in a slot and, as such, cannot be defined."),(0,r.kt)("li",{parentName:"ul"},"A pattern must use all symbols defined by the user.")),(0,r.kt)("h3",{id:"shapelessrecipebuilder"},"ShapelessRecipeBuilder"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShapelessRecipeBuilder")," is used to generate shapeless recipes. The builder can be initialized via ",(0,r.kt)("inlineCode",{parentName:"p"},"#shapeless"),". The recipe group, input ingredients, and the recipe unlock criteria can be specified before saving."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// In RecipeProvider#buildRecipes(writer)\nShapelessRecipeBuilder builder = ShapelessRecipeBuilder.shapeless(RecipeCategory.MISC, result)\n  .requires(item) // Add item to the recipe\n  .unlockedBy("criteria", criteria) // How the recipe is unlocked\n  .save(writer); // Add data to builder\n')),(0,r.kt)("h3",{id:"simplecookingrecipebuilder"},"SimpleCookingRecipeBuilder"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SimpleCookingRecipeBuilder")," is used to generate smelting, blasting, smoking, and campfire cooking recipes. Additionally, custom cooking recipes using the ",(0,r.kt)("inlineCode",{parentName:"p"},"SimpleCookingSerializer")," can also be data generated using this builder. The builder can be initialized via ",(0,r.kt)("inlineCode",{parentName:"p"},"#smelting"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#blasting"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#smoking"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"#campfireCooking"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"#cooking")," respectively. The recipe group and the recipe unlock criteria can be specified before saving."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// In RecipeProvider#buildRecipes(writer)\nSimpleCookingRecipeBuilder builder = SimpleCookingRecipeBuilder.smelting(input, RecipeCategory.MISC, result, experience, cookingTime)\n  .unlockedBy("criteria", criteria) // How the recipe is unlocked \n  .save(writer); // Add data to builder\n')),(0,r.kt)("h3",{id:"singleitemrecipebuilder"},"SingleItemRecipeBuilder"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SingleItemRecipeBuilder")," is used to generate stonecutting recipes. Additionally, custom single item recipes using a serializer like ",(0,r.kt)("inlineCode",{parentName:"p"},"SingleItemRecipe$Serializer")," can also be data generated using this builder. The builder can be initialized via ",(0,r.kt)("inlineCode",{parentName:"p"},"#stonecutting")," or through the constructor respectively. The recipe group and the recipe unlock criteria can be specified before saving."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// In RecipeProvider#buildRecipes(writer)\nSingleItemRecipeBuilder builder = SingleItemRecipeBuilder.stonecutting(input, RecipeCategory.MISC, result)\n  .unlockedBy("criteria", criteria) // How the recipe is unlocked\n  .save(writer); // Add data to builder\n')),(0,r.kt)("h2",{id:"non-recipebuilder-builders"},"Non-",(0,r.kt)("inlineCode",{parentName:"h2"},"RecipeBuilder")," Builders"),(0,r.kt)("p",null,"Some recipe builders do not implement ",(0,r.kt)("inlineCode",{parentName:"p"},"RecipeBuilder")," due to lacking features used by all previously mentioned recipes."),(0,r.kt)("h3",{id:"smithingtransformrecipebuilder"},"SmithingTransformRecipeBuilder"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SmithingTransformRecipeBuilder")," is used to generate smithing recipes which transform an item. Additionally, custom recipes using a serializer like ",(0,r.kt)("inlineCode",{parentName:"p"},"SmithingTransformRecipe$Serializer")," can also be data generated using this builder. The builder can be initialized via ",(0,r.kt)("inlineCode",{parentName:"p"},"#smithing")," or through the constructor respectively. The recipe unlock criteria can be specified before saving."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// In RecipeProvider#buildRecipes(writer)\nSmithingTransformRecipeBuilder builder = SmithingTransformRecipeBuilder.smithing(template, base, addition, RecipeCategory.MISC, result)\n  .unlocks("criteria", criteria) // How the recipe is unlocked\n  .save(writer, name); // Add data to builder\n')),(0,r.kt)("h3",{id:"smithingtrimrecipebuilder"},"SmithingTrimRecipeBuilder"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SmithingTrimRecipeBuilder")," is used to generate smithing recipes for armor trims. Additionally, custom upgrade recipes using a serializer like ",(0,r.kt)("inlineCode",{parentName:"p"},"SmithingTrimRecipe$Serializer")," can also be data generated using this builder. The builder can be initialized via ",(0,r.kt)("inlineCode",{parentName:"p"},"#smithingTrim")," or through the constructor respectively. The recipe unlock criteria can be specified before saving."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// In RecipeProvider#buildRecipes(writer)\nSmithingTrimRecipe builder = SmithingTrimRecipe.smithingTrim(template, base, addition, RecipeCategory.MISC)\n  .unlocks("criteria", criteria) // How the recipe is unlocked\n  .save(writer, name); // Add data to builder\n')),(0,r.kt)("h3",{id:"specialrecipebuilder"},"SpecialRecipeBuilder"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SpecialRecipeBuilder")," is used to generate empty JSONs for dynamic recipes that cannot easily be constrained to the recipe JSON format (dying armor, firework, etc.). The builder can be initialized via ",(0,r.kt)("inlineCode",{parentName:"p"},"#special"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// In RecipeProvider#buildRecipes(writer)\nSpecialRecipeBuilder.special(dynamicRecipeSerializer)\n  .save(writer, name); // Add data to builder\n")),(0,r.kt)("h2",{id:"conditional-recipes"},"Conditional Recipes"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/docs/resources/server/conditional"},"Conditional recipes")," can also be data generated via ",(0,r.kt)("inlineCode",{parentName:"p"},"ConditionalRecipe$Builder"),". The builder can be obtained using ",(0,r.kt)("inlineCode",{parentName:"p"},"#builder"),"."),(0,r.kt)("p",null,"Conditions for each recipe can be specified by first calling ",(0,r.kt)("inlineCode",{parentName:"p"},"#addCondition")," and then calling ",(0,r.kt)("inlineCode",{parentName:"p"},"#addRecipe")," after all conditions have been specified. This process can be repeated as many times as the programmer would like."),(0,r.kt)("p",null,"After all recipes have been specified, advancements can be added for each recipe at the end using ",(0,r.kt)("inlineCode",{parentName:"p"},"#generateAdvancement"),". Alternatively, the conditional advancement can be set using ",(0,r.kt)("inlineCode",{parentName:"p"},"#setAdvancement"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"// In RecipeProvider#buildRecipes(writer)\nConditionalRecipe.builder()\n  // Add the conditions for the recipe\n  .addCondition(...)\n  // Add recipe to return when conditions are true\n  .addRecipe(...)\n\n  // Add the next conditions for the next recipe\n  .addCondition(...)\n  // Add next recipe to return when the next conditions are true\n  .addRecipe(...)\n\n  // Create conditional advancement which uses the conditions\n  // and unlocking advancement in the recipes above\n  .generateAdvancement()\n  .build(writer, name);\n")),(0,r.kt)("h3",{id:"iconditionbuilder"},"IConditionBuilder"),(0,r.kt)("p",null,"To simplify adding conditions to conditional recipes without having to construct the instances of each condition instance manually, the extended ",(0,r.kt)("inlineCode",{parentName:"p"},"RecipeProvider")," can implement ",(0,r.kt)("inlineCode",{parentName:"p"},"IConditionBuilder"),". The interface adds methods to easily construct condition instances."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// In ConditionalRecipe$Builder#addCondition\n(\n  // If either \'examplemod:example_item\'\n  // OR \'examplemod:example_item2\' exists\n  // AND\n  // NOT FALSE\n\n  // Methods are defined by IConditionBuilder\n  and( \n    or(\n      itemExists("examplemod", "example_item"),\n      itemExists("examplemod", "example_item2")\n    ),\n    not(\n      FALSE()\n    )\n  )\n)\n')),(0,r.kt)("h2",{id:"custom-recipe-serializers"},"Custom Recipe Serializers"),(0,r.kt)("p",null,"Custom recipe serializers can be data generated by creating a builder that can construct a ",(0,r.kt)("inlineCode",{parentName:"p"},"FinishedRecipe"),". The finished recipe encodes the recipe data and its unlocking advancement, when present, to JSON. Additionally, the name and serializer of the recipe is also specified to know where to write to and what can decode the object when loading. Once a ",(0,r.kt)("inlineCode",{parentName:"p"},"FinishedRecipe")," is constructed, it simply needs to be passed to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Consumer")," supplied by ",(0,r.kt)("inlineCode",{parentName:"p"},"RecipeProvider#buildRecipes"),"."),(0,r.kt)("p",null,"!!! tip\n",(0,r.kt)("inlineCode",{parentName:"p"},"FinishedRecipe"),"s are flexible enough that any object transformation can be data generated, not just items."))}u.isMDXComponent=!0}}]);